"""
app.py
Portfolio Architect Streamlit Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò (AgentCore Runtime Î≤ÑÏ†Ñ)

AI Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏÑ§Í≥ÑÏÇ¨Í∞Ä Ïã§ÏãúÍ∞ÑÏúºÎ°ú ÏãúÏû• Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÏÑùÌïòÏó¨ 
ÎßûÏ∂§Ìòï Ìà¨Ïûê Ìè¨Ìä∏Ìè¥Î¶¨Ïò§Î•º Ï†úÏïàÌïòÎäî Ïõπ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò
"""

import streamlit as st
import json
import os
import sys
import boto3
import plotly.express as px
import plotly.graph_objects as go
import pandas as pd
from pathlib import Path

# ÏÉÅÏúÑ ÎîîÎ†âÌÜ†Î¶¨ Í≤ΩÎ°ú Ï∂îÍ∞Ä
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from config import AVAILABLE_PRODUCTS

# ================================
# ÌéòÏù¥ÏßÄ ÏÑ§Ï†ï Î∞è Ï¥àÍ∏∞Ìôî
# ================================

st.set_page_config(page_title="Portfolio Architect")
st.title("ü§ñ Portfolio Architect")

# Î∞∞Ìè¨ Ï†ïÎ≥¥ Î°úÎìú
CURRENT_DIR = Path(__file__).parent.resolve()
try:
    with open(CURRENT_DIR / "deployment_info.json", "r") as f:
        deployment_info = json.load(f)
    AGENT_ARN = deployment_info["agent_arn"]
    REGION = deployment_info["region"]
except Exception as e:
    st.error("Î∞∞Ìè¨ Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. deploy.pyÎ•º Î®ºÏ†Ä Ïã§ÌñâÌï¥Ï£ºÏÑ∏Ïöî.")
    st.stop()

# AgentCore ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ï†ï
agentcore_client = boto3.client('bedrock-agentcore', region_name=REGION)

# ================================
# Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
# ================================

def extract_json_from_text(text_content):
    """
    ÌÖçÏä§Ìä∏ÏóêÏÑú JSON Îç∞Ïù¥ÌÑ∞Î•º Ï∂îÏ∂úÌïòÎäî Ìï®Ïàò
    
    Args:
        text_content (str): JSONÏù¥ Ìè¨Ìï®Îêú ÌÖçÏä§Ìä∏
        
    Returns:
        dict: ÌååÏã±Îêú JSON Îç∞Ïù¥ÌÑ∞ ÎòêÎäî None
    """
    if isinstance(text_content, dict):
        return text_content
    
    if not isinstance(text_content, str):
        return None
    
    # JSON Î∏îÎ°ù Ï∞æÍ∏∞
    start_idx = text_content.find('{')
    end_idx = text_content.rfind('}') + 1
    
    if start_idx != -1 and end_idx != -1:
        try:
            json_str = text_content[start_idx:end_idx]
            return json.loads(json_str)
        except json.JSONDecodeError:
            return None
    
    return None

def parse_tool_result(result_text):
    """
    ÎèÑÍµ¨ Ïã§Ìñâ Í≤∞Í≥ºÏóêÏÑú Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î•º Ï∂îÏ∂úÌïòÎäî Ìï®Ïàò
    
    Args:
        result_text (str): MCP Server ÏùëÎãµ JSON Î¨∏ÏûêÏó¥
        
    Returns:
        dict: ÌååÏã±Îêú Îç∞Ïù¥ÌÑ∞
    """
    try:
        # MCP Server ÏùëÎãµÏùÄ ÏßÅÏ†ë JSON ÌòïÌÉúÏùº Ïàò ÏûàÏùå
        if isinstance(result_text, str):
            parsed_result = json.loads(result_text)
        else:
            parsed_result = result_text
            
        # Lambda ÌòïÏãùÏù∏ Í≤ΩÏö∞
        if "response" in parsed_result and "payload" in parsed_result["response"]:
            return parsed_result["response"]["payload"]["body"]
        # ÏßÅÏ†ë Îç∞Ïù¥ÌÑ∞Ïù∏ Í≤ΩÏö∞
        else:
            return parsed_result
            
    except json.JSONDecodeError as e:
        print(f"JSON ÌååÏã± ÏóêÎü¨: {e}")
        print(f"ÏõêÎ≥∏ ÌÖçÏä§Ìä∏: {result_text}")
        return result_text

# ================================
# Îç∞Ïù¥ÌÑ∞ ÌëúÏãú Ìï®ÏàòÎì§
# ================================

def display_available_products(container, products_data):
    """
    ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ìà¨Ïûê ÏÉÅÌíà Î™©Î°ùÏùÑ ÌÖåÏù¥Î∏î ÌòïÌÉúÎ°ú ÌëúÏãú
    
    Args:
        container: Streamlit Ïª®ÌÖåÏù¥ÎÑà
        products_data: ÏÉÅÌíà Îç∞Ïù¥ÌÑ∞ (dict ÎòêÎäî JSON Î¨∏ÏûêÏó¥)
    """
    try:
        # Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ Ï†ïÍ∑úÌôî
        if isinstance(products_data, str):
            products = json.loads(products_data)
        else:
            products = products_data
        
        # DataFrame ÏÉùÏÑ±
        df = pd.DataFrame(
            [[ticker, desc] for ticker, desc in products.items()],
            columns=['Ìã∞Ïª§', 'ÏÑ§Î™Ö']
        )
        
        # ÌÖåÏù¥Î∏î ÌëúÏãú
        container.markdown("**ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ìà¨Ïûê ÏÉÅÌíà**")
        container.dataframe(
            df,
            use_container_width=True,
            hide_index=True,
            column_config={
                "Ìã∞Ïª§": st.column_config.TextColumn(width="small"),
                "ÏÑ§Î™Ö": st.column_config.TextColumn(width="large")
            }
        )
    except Exception as e:
        container.error(f"ÏÉÅÌíà Î™©Î°ù ÌëúÏãú Ïò§Î•ò: {str(e)}")

def display_product_data(container, price_data):
    """
    ETF Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞Î•º Ï∞®Ìä∏Î°ú ÌëúÏãú
    
    Args:
        container: Streamlit Ïª®ÌÖåÏù¥ÎÑà
        price_data: Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ (dict ÎòêÎäî JSON Î¨∏ÏûêÏó¥)
    """
    try:
        # Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ Ï†ïÍ∑úÌôî
        if isinstance(price_data, str):
            data = json.loads(price_data)
        else:
            data = price_data
        
        # Í∞Å ETFÎ≥ÑÎ°ú Í∞úÎ≥Ñ Ï∞®Ìä∏ ÌëúÏãú
        for ticker, prices in data.items():
            df = pd.DataFrame.from_dict(prices, orient='index', columns=['Price'])
            df.index = pd.to_datetime(df.index)
            df = df.sort_index()
            
            fig = go.Figure()
            fig.add_trace(
                go.Scatter(
                    x=df.index,
                    y=df['Price'],
                    mode='lines',
                    name=ticker,
                    line=dict(width=2)
                )
            )
            
            fig.update_layout(
                title=f"{ticker} Í∞ÄÍ≤© Ï∂îÏù¥",
                xaxis_title="ÎÇ†Ïßú",
                yaxis_title="Í∞ÄÍ≤© ($)",
                height=400,
                showlegend=True,
                hovermode='x unified'
            )
            
            container.plotly_chart(fig, use_container_width=True)
                
    except Exception as e:
        container.error(f"Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ ÌëúÏãú Ïò§Î•ò: {str(e)}")

def create_pie_chart(allocation_data, chart_title=""):
    """
    Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î∞∞Î∂ÑÏùÑ ÏúÑÌïú ÌååÏù¥ Ï∞®Ìä∏ ÏÉùÏÑ±
    
    Args:
        allocation_data (dict): ÏûêÏÇ∞ Î∞∞Î∂Ñ Îç∞Ïù¥ÌÑ∞
        chart_title (str): Ï∞®Ìä∏ Ï†úÎ™©
        
    Returns:
        plotly.graph_objects.Figure: ÌååÏù¥ Ï∞®Ìä∏
    """
    fig = go.Figure(data=[go.Pie(
        labels=list(allocation_data.keys()),
        values=list(allocation_data.values()),
        hole=.3,
        textinfo='label+percent',
        marker=dict(colors=px.colors.qualitative.Set3)
    )])
    
    fig.update_layout(
        title=chart_title,
        showlegend=True,
        width=400,
        height=400
    )
    return fig

def display_portfolio_suggestion(container, portfolio_content):
    """
    ÏµúÏ¢Ö Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Ï†úÏïà Í≤∞Í≥ºÎ•º ÌëúÏãú
    
    Args:
        container: Streamlit Ïª®ÌÖåÏù¥ÎÑà
        portfolio_content: Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Îç∞Ïù¥ÌÑ∞ (dict ÎòêÎäî JSON Î¨∏ÏûêÏó¥)
    """
    try:
        # JSON Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
        data = extract_json_from_text(portfolio_content)
        if not data:
            container.error("Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
            return
        
        # 2Ïó¥ Î†àÏù¥ÏïÑÏõÉÏúºÎ°ú ÌëúÏãú
        col1, col2 = container.columns([1, 1])
        
        with col1:
            st.markdown("**Ìè¨Ìä∏Ìè¥Î¶¨Ïò§**")
            fig = create_pie_chart(
                data["portfolio_allocation"],
                "Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏûêÏÇ∞ Î∞∞Î∂Ñ"
            )
            st.plotly_chart(fig)
        
        with col2:
            st.markdown("**Ìà¨Ïûê Ï†ÑÎûµ**")
            st.info(data["strategy"])
        
        # ÏÉÅÏÑ∏ Í∑ºÍ±∞ ÌëúÏãú
        container.markdown("**ÏÉÅÏÑ∏ Í∑ºÍ±∞**")
        container.write(data["reason"])
        
    except Exception as e:
        container.error(f"Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÌëúÏãú Ïò§Î•ò: {str(e)}")
        container.text(str(portfolio_content))

# ================================
# Î©îÏù∏ Ï≤òÎ¶¨ Ìï®Ïàò
# ================================

def invoke_portfolio_architect(financial_analysis):
    """
    AgentCore RuntimeÏùÑ Ìò∏Ï∂úÌïòÏó¨ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏÑ§Í≥Ñ ÏàòÌñâ
    
    Args:
        financial_analysis (str): Ïû¨Î¨¥ Î∂ÑÏÑù Í≤∞Í≥º JSON
        
    Returns:
        dict: Ïã§Ìñâ Í≤∞Í≥º (status, output_text)
    """
    try:
        # AgentCore Runtime Ìò∏Ï∂ú
        response = agentcore_client.invoke_agent_runtime(
            agentRuntimeArn=AGENT_ARN,
            qualifier="DEFAULT",
            payload=json.dumps({"financial_analysis": financial_analysis})
        )
        
        # UI Ïª®ÌÖåÏù¥ÎÑà ÏÑ§Ï†ï
        placeholder = st.container()
        placeholder.subheader("Bedrock Reasoning")
        
        # ÏÉÅÌÉú Î≥ÄÏàò Ï¥àÍ∏∞Ìôî
        current_thinking = ""
        current_text_placeholder = placeholder.empty()
        tool_id_to_name = {}  # tool_use_idÏôÄ tool_name Îß§Ìïë

        # Ïä§Ìä∏Î¶¨Î∞ç ÏùëÎãµ Ï≤òÎ¶¨
        for line in response["response"].iter_lines(chunk_size=1):
            try:
                event_data = json.loads(line.decode("utf-8")[6:])
                event_type = event_data.get("type")
                
                if event_type == "text_chunk":
                    # AI ÏÉùÍ∞Å Í≥ºÏ†ïÏùÑ Ïã§ÏãúÍ∞ÑÏúºÎ°ú ÌëúÏãú
                    chunk_data = event_data.get("data", "")
                    current_thinking += chunk_data
                    
                    if current_thinking.strip():
                        with current_text_placeholder.chat_message("assistant"):
                            st.markdown(current_thinking)
                
                elif event_type == "tool_use":
                    # ÎèÑÍµ¨ ÏÇ¨Ïö© ÏãúÏûë - Îß§Ìïë Ï†ïÎ≥¥ Ï†ÄÏû•
                    tool_name = event_data.get("tool_name", "")
                    tool_use_id = event_data.get("tool_use_id", "")
                    
                    # Ïã§Ï†ú Ìï®ÏàòÎ™Ö Ï∂îÏ∂ú (target-portfolio-architect___get_available_products -> get_available_products)
                    actual_tool_name = tool_name.split("___")[-1] if "___" in tool_name else tool_name
                    tool_id_to_name[tool_use_id] = actual_tool_name
                
                elif event_type == "tool_result":
                    # ÎèÑÍµ¨ Ïã§Ìñâ Í≤∞Í≥º Ï≤òÎ¶¨
                    tool_use_id = event_data.get("tool_use_id", "")
                    actual_tool_name = tool_id_to_name.get(tool_use_id, "unknown")
                    
                    tool_content = event_data.get("content", [{}])
                    if tool_content and len(tool_content) > 0:
                        result_text = tool_content[0].get("text", "{}")
                        body = parse_tool_result(result_text)
                        
                        # ÎèÑÍµ¨ ÌÉÄÏûÖÏóê Îî∞Îùº Ï†ÅÏ†àÌïú ÌëúÏãú Ìï®Ïàò Ìò∏Ï∂ú
                        if actual_tool_name == "get_available_products":
                            display_available_products(placeholder, body)
                        elif actual_tool_name == "get_product_data":
                            display_product_data(placeholder, body)
                    
                    # ÎèÑÍµ¨ Í≤∞Í≥º Ï≤òÎ¶¨ ÌõÑ ÏÉùÍ∞Å ÌÖçÏä§Ìä∏ Î¶¨ÏÖã Î∞è ÏÉàÎ°úÏö¥ placeholder ÏÉùÏÑ±
                    current_thinking = ""
                    if tool_use_id in tool_id_to_name:
                        del tool_id_to_name[tool_use_id]
                    current_text_placeholder = placeholder.empty()
                
                elif event_type == "streaming_complete":
                    # ÎßàÏßÄÎßâ AI ÏÉùÍ∞Å ÌëúÏãú ÌõÑ ÏôÑÎ£å
                    if current_thinking.strip():
                        with current_text_placeholder.chat_message("assistant"):
                            st.markdown(current_thinking.strip())
                    break
                    
            except json.JSONDecodeError:
                continue
        
        # ÏµúÏ¢Ö Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í≤∞Í≥º ÌëúÏãú
        placeholder.divider()
        placeholder.markdown("ü§ñ **Portfolio Architect**")
        placeholder.subheader("üìå Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏÑ§Í≥Ñ")
        display_portfolio_suggestion(placeholder, current_thinking)
        
        return {
            "status": "success",
            "output_text": current_thinking
        }
        
    except Exception as e:
        return {
            "status": "error",
            "error": str(e)
        }

# ================================
# UI Íµ¨ÏÑ±
# ================================

# ÏïÑÌÇ§ÌÖçÏ≤ò ÏÑ§Î™Ö
with st.expander("ÏïÑÌÇ§ÌÖçÏ≤ò", expanded=True):
    st.markdown("""
    ### üîÑ MCP Server Architecture (Tool Use Pattern)
    ```
    Ïû¨Î¨¥ Î∂ÑÏÑù Í≤∞Í≥º ‚Üí Portfolio Architect ‚Üí MCP Server ‚Üí ETF Îç∞Ïù¥ÌÑ∞ ‚Üí ÏµúÏ¢Ö Ìè¨Ìä∏Ìè¥Î¶¨Ïò§
    ```
    
    **Íµ¨ÏÑ± ÏöîÏÜå:**
    - **Portfolio Architect Agent**: AI Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏÑ§Í≥ÑÏÇ¨ (AgentCore Runtime)
    - **MCP Server**: ETF Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå ÎèÑÍµ¨ ÏÑúÎ≤Ñ (AgentCore Runtime)
    - **Tool Use Pattern**: MCP ÌîÑÎ°úÌÜ†ÏΩúÏùÑ ÌÜµÌïú ÎèÑÍµ¨ ÌôúÏö©
    - **yfinance**: Ïã§ÏãúÍ∞Ñ ETF Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§
    
    **ÏÇ¨Ïö© ÎèÑÍµ¨:**
    - `get_available_products()`: 30Í∞ú ETF ÏÉÅÌíà Î™©Î°ù Ï°∞Ìöå
    - `get_product_data(ticker)`: Ïã§ÏãúÍ∞Ñ Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (ÏµúÍ∑º 3Í∞úÏõî)
    """)

# ÏûÖÎ†• Ìèº
st.markdown("**Ïû¨Î¨¥ Î∂ÑÏÑù Í≤∞Í≥º ÏûÖÎ†•(ü§ñ Financial Analyst)**")

financial_analysis = st.text_area(
    "JSON ÌòïÏãù",
    value='{"risk_profile": "Í≥µÍ≤©Ï†Å", "risk_profile_reason": "ÎÇòÏù¥Í∞Ä 35ÏÑ∏Î°ú Ï†äÍ≥†, Ï£ºÏãù Ìà¨Ïûê Í≤ΩÌóòÏù¥ 10ÎÖÑÏúºÎ°ú ÏÉÅÎãπÌûà ÎßéÏúºÎ©∞, Ï¥ù Ìà¨Ïûê Í∞ÄÎä• Í∏àÏï°Ïù¥ 5000ÎßåÏõêÏúºÎ°ú ÏÉÅÎãπÌûà ÎÜíÏùÄ Ìé∏ÏûÖÎãàÎã§.", "required_annual_return_rate": 40.0, "return_rate_reason": "ÌïÑÏöî Ïó∞Í∞Ñ ÏàòÏùµÎ•†ÏùÄ (70000000 - 50000000) / 50000000 * 100 = 40.00%ÏûÖÎãàÎã§."}',
    height=200
)

submitted = st.button("Î∂ÑÏÑù ÏãúÏûë", use_container_width=True)

# Î©îÏù∏ Ïã§Ìñâ Î°úÏßÅ
if submitted and financial_analysis:
    st.divider()
    
    with st.spinner("AI is processing..."):
        try:
            result = invoke_portfolio_architect(financial_analysis)
            
            if result['status'] == 'error':
                st.error(f"‚ùå Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {result.get('error', 'Unknown error')}")
                
        except Exception as e:
            st.error(f"‚ùå ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}")